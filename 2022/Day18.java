import java.util.*;

public class Day18 {
  // This is disgusting, but basically I find the top most cube (UP side) and from there run a DFS counting the number
  // of different colors I can reach to. From a CubeSide there must be only 4 potential CubeSides we can reach to,
  // which is generated by CubeSide::adjacentCubeSides.
  private static void count(UnionFind uf, Map<CubeSide, Integer> cubeSides, CubeSide cs, Set<CubeSide> visited, Set<Integer> colors) {
    visited.add(cs);
    colors.add(uf.find(cubeSides.get(cs)));
    for (CubeSide adj : cs.adjacentCubeSides(cubeSides.keySet())) {
      if (cubeSides.containsKey(adj) && uf.find(cubeSides.get(adj)) != uf.find(0) && !visited.contains(adj)) {
        count(uf, cubeSides, adj, visited, colors);
      }
    }
  }

  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    UnionFind uf = new UnionFind(1);
    Map<CubeSide, Integer> cubeSides = new HashMap<>();
    int maxDimension = 0;
    Cube highest = null;
    while (sc.hasNext()) {
      Integer[] coord = Arrays.stream(sc.next().split(",")).map(s -> Integer.parseInt(s)).toArray(Integer[]::new);
      int x = coord[0], y = coord[1], z = coord[2];
      Cube cube = new Cube(x, y, z);
      maxDimension = Math.max(maxDimension, Math.max(x, Math.max(y, z)));
      if (highest == null || z > highest.z()) {
        highest = cube;
      }

      for (Side s : Side.values()) {
        CubeSide cs = new CubeSide(cube, s);
        cubeSides.put(cs, cubeSides.size() + 1);
        uf.expandTo(cubeSides.size() + 1);
        CubeSide opposite = cs.opposite();
        if (cubeSides.containsKey(opposite)) {
          // These two cubes are together
          uf.union(0, cubeSides.get(cs));
          uf.union(0, cubeSides.get(opposite));
        }
      }
    }
    System.out.println(uf.size() - 1);

    Set<CubeSide> visited = new HashSet<>();
    Set<Integer> colors = new HashSet<>();
    count(uf, cubeSides, new CubeSide(highest, Side.UP), visited, colors);
    System.out.println(colors.size());
  }

  enum Side {
    UP(0, 0, 1),
    DOWN(0, 0, -1),
    RIGHT(1, 0, 0),
    LEFT(-1, 0, 0),
    BACK(0, 1, 0),
    FRONT(0, -1, 0);

    final int x, y, z;

    Side(int x, int y, int z) {
      this.x = x;
      this.y = y;
      this.z = z;
    }

    Side opposite() {
      switch (this) {
        case UP:
          return DOWN;
        case DOWN:
          return UP;
        case LEFT:
          return RIGHT;
        case RIGHT:
          return LEFT;
        case FRONT:
          return BACK;
        case BACK:
          return FRONT;
      }
      throw new IllegalArgumentException("What's %s?".formatted(this));
    }

    Set<Side> adjacentSides() {
      switch (this) {
        case UP:
        case DOWN:
          return Set.of(LEFT, RIGHT, FRONT, BACK);
        case LEFT:
        case RIGHT:
          return Set.of(UP, DOWN, FRONT, BACK);
        case FRONT:
        case BACK:
          return Set.of(LEFT, RIGHT, UP, DOWN);
      }
      throw new IllegalArgumentException("What's %s?".formatted(this));
    }
  }

  record Cube(int x, int y, int z) {
    Cube add(Side side) {
      return new Cube(x + side.x, y + side.y, z + side.z);
    }
  }

  record CubeSide(Cube cube, Side side) {
    CubeSide opposite() {
      return new CubeSide(cube.add(side), side.opposite());
    }

    Set<CubeSide> adjacentCubeSides(Set<CubeSide> cubeSides) {
      Set<CubeSide> adj = new HashSet<>();
      for (Side s : side.adjacentSides()) {
        // Comments assume this side is FRONT and s is UP. There's exactly one CubeSide attach to this side
        // per adjacent side. This is found in the order specified below: either it's a cube side in L shape from this
        // (diagonally from this cube), a cube right next ot it, or the same cube with a different side.
        CubeSide cs;
        // Cube is diagonally UP and FRONT to it, side is DOWN
        if (cubeSides.contains(cs = new CubeSide(cube.add(s).add(side), s.opposite()))) {
          adj.add(cs);
          continue;
        }
        // Cube UP to it, FRONT side
        if (cubeSides.contains(cs = new CubeSide(cube.add(s), side))) {
          adj.add(cs);
          continue;
        }
        // Same cube, UP side
        if (cubeSides.contains(cs = new CubeSide(cube, s))) {
          adj.add(cs);
        }
      }
      return adj;
    }
  }

  private static class UnionFind {
    List<Integer> parent;
    List<Integer> rank;

    public UnionFind(int initialCapacity) {
      parent = new ArrayList<>();
      rank = new ArrayList<>();
      for (int i = 0; i < initialCapacity; i++) {
        parent.add(i);
        rank.add(0);
      }
    }

    // Return number of sets. Takes linear time.
    public int size() {
      Set<Integer> s = new HashSet<>();
      for (int i = 0; i < parent.size(); i++) {
        s.add(find(i));
      }
      return s.size();
    }

    // Increase capacity of set to the given size.
    public void expandTo(int n) {
      for (int i = parent.size(); i < n; i++) {
        parent.add(i);
        rank.add(0);
      }
    }

    // Joins two sets.
    public void union(int x, int y) {
      int px = find(x);
      int py = find(y);

      if (px == py) {
        // Values are already in the same set.
        return;
      }

      // Switch so that rank[px] >= rank[py]
      if (rank.get(py) > rank.get(px)) {
        int aux = px;
        px = py;
        py = aux;
      }

      parent.set(py, px);
      if (rank.get(px) == rank.get(py)) {
        // Increase rank only if the height of x increased.
        rank.set(px, rank.get(py) + 1);
      }
    }

    // Returns parent of x.
    public int find(int x) {
      expandTo(x + 1); // make sure there's enough capacity
      while (parent.get(x) != x) {
        x = parent.get(x);
      }
      return x;
    }
  }
}